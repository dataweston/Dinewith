generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
  directUrl = env("POSTGRES_URL_NON_POOLING")
}

enum UserRole {
  GUEST
  HOST
  MODERATOR
  ADMIN
}

enum HostApplicationStatus {
  DRAFT
  SUBMITTED
  APPROVED
  REJECTED
}

enum KycStatus {
  NOT_STARTED
  IN_PROGRESS
  COMPLETED
  FAILED
}

model User {
  id               String             @id @default(cuid())
  email            String             @unique
  name             String?
  password         String
  salt             String
  role             UserRole           @default(GUEST)
  createdAt        DateTime           @default(now())
  updatedAt        DateTime           @updatedAt
  hostApplications HostApplication[]
  hostProfile      HostProfile?
  bookings         Booking[]
  sentMessages     Message[]          @relation("SentMessages")
  receivedMessages Message[]          @relation("ReceivedMessages")
  streams          Stream[]
  reports          Report[]
  reportedContent  Report[]           @relation("ReportedContent")
}

model HostApplication {
  id               String                 @id @default(cuid())
  userId           String
  user             User                   @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // Basic Info
  businessName     String?
  phone            String?
  bio              String?
  experienceYears  Int?
  cuisineTypes     String[]               @default([])
  
  // Location
  address          String?
  city             String?
  state            String?
  zipCode          String?
  
  // KYC & Verification
  kycStatus        KycStatus              @default(NOT_STARTED)
  kycStartedAt     DateTime?
  kycCompletedAt   DateTime?
  kycData          String?                // JSON blob for KYC metadata
  
  // Application Status
  status           HostApplicationStatus  @default(DRAFT)
  submittedAt      DateTime?
  reviewedAt       DateTime?
  reviewedBy       String?                // User ID of moderator
  reviewNotes      String?
  
  createdAt        DateTime               @default(now())
  updatedAt        DateTime               @updatedAt
  
  @@index([userId])
  @@index([status])
}

enum WaitlistStatus {
  PENDING
  CONTACTED
}

model City {
  id              String          @id @default(cuid())
  name            String
  slug            String          @unique
  stateName       String
  stateSlug       String
  stateCode       String
  headline        String?
  description     String?
  heroCopy        String?
  heroImage       String?
  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt
  waitlistEntries WaitlistEntry[]

  @@index([stateSlug])
}

model WaitlistEntry {
  id        String          @id @default(cuid())
  email     String
  name      String?
  guests    Int?
  notes     String?
  source    String?         @default("city-landing")
  status    WaitlistStatus  @default(PENDING)
  cityId    String
  city      City            @relation(fields: [cityId], references: [id], onDelete: Cascade)
  createdAt DateTime        @default(now())
  updatedAt DateTime        @updatedAt

  @@unique([email, cityId])
}

// Marketplace Models

model HostProfile {
  id          String    @id @default(cuid())
  userId      String    @unique
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  displayName String
  avatar      String?
  bio         String?
  tagline     String?
  location    String?
  
  // Structured profile data
  cuisines    String[]  @default([])
  languages   String[]  @default([])
  
  // Meta
  isActive    Boolean   @default(true)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  
  listings    Listing[]
  
  @@index([isActive])
}

enum ListingStatus {
  DRAFT
  SUBMITTED
  ACTIVE
  PAUSED
  REJECTED
}

enum ListingType {
  IN_PERSON
  VIRTUAL
  HYBRID
}

model Listing {
  id            String        @id @default(cuid())
  hostProfileId String
  hostProfile   HostProfile   @relation(fields: [hostProfileId], references: [id], onDelete: Cascade)
  
  title         String
  slug          String        @unique
  type          ListingType
  status        ListingStatus @default(DRAFT)
  
  // Pricing
  priceAmount   Int           // in cents
  priceCurrency String        @default("USD")
  duration      Int?          // in minutes
  maxGuests     Int           @default(1)
  
  // Content (WYSIWYG JSON)
  content       String        @db.Text // JSON blob
  
  // Location (for in-person)
  city          String?
  state         String?
  country       String?       @default("US")
  
  // Meta
  viewCount     Int           @default(0)
  bookingCount  Int           @default(0)
  
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt
  publishedAt   DateTime?
  
  availability  Availability[]
  bookings      Booking[]
  reviews       Review[]
  
  @@index([status])
  @@index([type])
  @@index([hostProfileId])
  @@index([city])
}

enum AvailabilityType {
  SPECIFIC_DATE
  RECURRING
}

model Availability {
  id        String           @id @default(cuid())
  listingId String
  listing   Listing          @relation(fields: [listingId], references: [id], onDelete: Cascade)
  
  type      AvailabilityType
  
  // For specific dates
  startTime DateTime?
  endTime   DateTime?
  
  // For recurring (JSON with day of week, time ranges)
  recurring String?          @db.Text // JSON blob
  
  isBooked  Boolean          @default(false)
  createdAt DateTime         @default(now())
  updatedAt DateTime         @updatedAt
  
  @@index([listingId])
  @@index([startTime])
}

enum BookingStatus {
  REQUESTED
  ACCEPTED
  AUTHORIZED
  COMPLETED
  CANCELED
  REFUNDED
  NO_SHOW
}

model Booking {
  id              String        @id @default(cuid())
  listingId       String
  listing         Listing       @relation(fields: [listingId], references: [id])
  guestId         String
  guest           User          @relation(fields: [guestId], references: [id])
  
  status          BookingStatus @default(REQUESTED)
  
  // Booking details
  scheduledStart  DateTime
  scheduledEnd    DateTime
  guestCount      Int           @default(1)
  
  // Pricing
  totalAmount     Int           // in cents
  platformFee     Int           // in cents
  hostAmount      Int           // in cents
  
  // Payment tracking (stub)
  paymentIntentId String?
  authorizedAt    DateTime?
  capturedAt      DateTime?
  refundedAt      DateTime?
  
  // Communication
  guestNotes      String?       @db.Text
  hostNotes       String?       @db.Text
  cancelReason    String?
  
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt
  
  messages        Message[]
  review          Review?
  
  @@index([listingId])
  @@index([guestId])
  @@index([status])
  @@index([scheduledStart])
}

model Message {
  id         String   @id @default(cuid())
  bookingId  String
  booking    Booking  @relation(fields: [bookingId], references: [id], onDelete: Cascade)
  
  senderId   String
  sender     User     @relation("SentMessages", fields: [senderId], references: [id])
  recipientId String
  recipient  User     @relation("ReceivedMessages", fields: [recipientId], references: [id])
  
  content    String   @db.Text
  isRead     Boolean  @default(false)
  
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  
  @@index([bookingId])
  @@index([senderId])
  @@index([recipientId])
  @@index([createdAt])
}

// Streaming & Live Features

enum StreamStatus {
  CREATED
  LIVE
  ENDED
  ARCHIVED
}

enum StreamType {
  ONE_TO_ONE
  SMALL_GROUP
  BROADCAST
}

model Stream {
  id              String       @id @default(cuid())
  hostId          String
  host            User         @relation(fields: [hostId], references: [id])
  
  title           String
  description     String?      @db.Text
  type            StreamType
  status          StreamStatus @default(CREATED)
  
  // Livepeer integration
  livepeerStreamId String?     @unique
  playbackId       String?
  streamKey        String?
  
  // Agora integration (for 1:1)
  agoraChannelName String?
  agoraAppId       String?
  
  // VOD settings
  vodEnabled       Boolean      @default(true)
  vodUrl           String?
  vodExpiresAt     DateTime?    // 7-day retention
  vodDeletedAt     DateTime?    // Track when VOD was cleaned up
  
  // Meta
  viewerCount      Int          @default(0)
  maxViewers       Int          @default(0)
  duration         Int?         // in seconds
  
  startedAt        DateTime?
  endedAt          DateTime?
  createdAt        DateTime     @default(now())
  updatedAt        DateTime     @updatedAt
  
  reports          Report[]
  
  @@index([hostId])
  @@index([status])
  @@index([vodExpiresAt])
}

// Payment & Fee Tracking

enum PaymentProcessor {
  BRAINTREE
  SQUARE
}

enum FeeTransactionType {
  PLATFORM_FEE
  REFUND
  CHARGEBACK
}

model FeeTransaction {
  id                String              @id @default(cuid())
  bookingId         String
  
  type              FeeTransactionType
  processor         PaymentProcessor
  
  // Amounts in cents
  bookingTotal      Int
  platformFee       Int                 // 4% of booking total
  hostPayout        Int
  
  // Payment processor IDs
  transactionId     String?
  paymentIntentId   String?
  
  // Status
  processed         Boolean             @default(false)
  processedAt       DateTime?
  
  // Meta
  metadata          String?             @db.Text // JSON blob
  createdAt         DateTime            @default(now())
  updatedAt         DateTime            @updatedAt
  
  @@index([bookingId])
  @@index([processed])
}

// Moderation & Reporting

enum ReportType {
  LISTING
  STREAM
  USER
  MESSAGE
}

enum ReportReason {
  INAPPROPRIATE_CONTENT
  HARASSMENT
  SPAM
  FRAUD
  SAFETY_CONCERN
  OTHER
}

enum ReportStatus {
  PENDING
  REVIEWING
  RESOLVED
  DISMISSED
}

model Report {
  id              String        @id @default(cuid())
  reporterId      String
  reporter        User          @relation(fields: [reporterId], references: [id])
  
  type            ReportType
  reason          ReportReason
  status          ReportStatus  @default(PENDING)
  
  // Content references
  reportedUserId  String?
  reportedUser    User?         @relation("ReportedContent", fields: [reportedUserId], references: [id])
  listingId       String?
  streamId        String?
  stream          Stream?       @relation(fields: [streamId], references: [id])
  
  description     String        @db.Text
  
  // Resolution
  reviewedBy      String?
  reviewedAt      DateTime?
  resolution      String?       @db.Text
  
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt
  
  @@index([reporterId])
  @@index([type])
  @@index([status])
  @@index([reportedUserId])
  @@index([listingId])
  @@index([streamId])
}

// Reviews & Ratings

model Review {
  id              String        @id @default(cuid())
  bookingId       String        @unique
  booking         Booking       @relation(fields: [bookingId], references: [id], onDelete: Cascade)
  listingId       String
  listing         Listing       @relation(fields: [listingId], references: [id])
  
  reviewerId      String
  hostProfileId   String
  
  rating          Int           // 1-5 stars
  comment         String?       @db.Text
  
  // Review aspects
  communicationRating Int?      // 1-5
  experienceRating    Int?      // 1-5
  valueRating         Int?      // 1-5
  
  // Moderation
  isPublished     Boolean       @default(true)
  flaggedAt       DateTime?
  
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt
  
  @@index([listingId])
  @@index([reviewerId])
  @@index([hostProfileId])
  @@index([rating])
  @@index([isPublished])
}

// Payouts & Host Earnings

enum PayoutStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
  CANCELED
}

model Payout {
  id              String        @id @default(cuid())
  hostProfileId   String
  
  // Amount in cents
  amount          Int
  currency        String        @default("USD")
  
  // Status tracking
  status          PayoutStatus  @default(PENDING)
  
  // Stripe Connect or similar integration
  accountId       String?       // External account ID (e.g., Stripe Connect)
  transferId      String?       // External transfer ID
  
  // Time tracking
  requestedAt     DateTime      @default(now())
  processedAt     DateTime?
  completedAt     DateTime?
  failedAt        DateTime?
  
  // Metadata
  notes           String?       @db.Text
  failureReason   String?
  
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt
  
  @@index([hostProfileId])
  @@index([status])
  @@index([requestedAt])
}
